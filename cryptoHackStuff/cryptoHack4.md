---
layout: page
title: Mathematics - Modular Math / Lattices
---
<hr/>

The Mathematics section consists of 22 challenges. The challenges are subdivided into 6 different stages : Modular Math, Lattices, Probability, Brainteasers Part 1, Brainteasers Part 2 and Primes. Below are the writeups for the ones I managed to complete for the Modular Math and Lattices sections :

<br/>

# Quadratic Residues (Modular Math)

![CryptoHack Image](/assets/img/exploitImages/cryptoHack/img47.png)

As shown in the image above, I have to first find out which of the numbers 14,6 and 11 is a quadratic residue when the modulo is p = 29. It turns out that only 6 is a quadratic residue. Then the challenge says that the flag is the smaller corresponding root to the quadratic residue 6. 
 
This <a href="https://www.youtube.com/watch?v=M6gDsFhQugM" target="_blank">video</a> does a pretty neat job of explaining what quadratic residues are.

I wrote a program for calculating the quadratic residue for corresponding roots : 

```python

#!/usr/bin/env python3

#x^2 congruent to c mod(p)

p = 29

for i in range (p):
    temp = (i*i) % p
    print((i), " squared mod 5 is : ", temp)

```

When I run my program as shown below, the corresponding roots to a quadratic residue of 6 is 8 and 21. Therefore the flag is 8.

![CryptoHack Image](/assets/img/exploitImages/cryptoHack/img48.png)

**Flag :** 8

<br/>

# Legendre Symbol (Modular Math)

![CryptoHack Image](/assets/img/exploitImages/cryptoHack/img49.png)

As shown in the image above, I am supposed to find the quadratic residue from the list of 10 integers given an odd prime (the output.txt files contains the odd prime and 10 ints). So as explained above, I could use the Legendre symbol to compute the single quadratic residue by using `pow(a,(p-1)/2,p)` when given an integer `a`. However, when I was writing this in Python, I had to replace the `/` with `//` because the double slash is the floor division operator. It produces the floor of the quotient of its operands, without floating-point rounding for integer operands. The single slash was not giving any result.

After finding the quadratic residue, I have to calculate the square root. The Wikipedia article on <a href="https://en.wikipedia.org/wiki/Quadratic_residue" target="_blank">Quadratic Residues</a> explains that when solving x^2 congruent to a mod (p) where a is the quadratic residue and p is the odd prime, the root which gives x equals plus-minus ( a ^ (p+1) / 4 ) % p. This is summarized in the image below :

![CryptoHack Image](/assets/img/exploitImages/cryptoHack/img51.png)

So I wrote the following Python script in order to get the root :

```python

#!/usr/bin/env python3

prime = 101524035174539890485408575671085261788758965189060164484385690801466167356667036677932998889725476582421738788500738738503134356158197247473850273565349249573867251280253564698939768700489401960767007716413932851838937641880157263936985954881657889497583485535527613578457628399173971810541670838543309159139

ints = [25081841204695904475894082974192007718642931811040324543182130088804239047149283334700530600468528298920930150221871666297194395061462592781551275161695411167049544771049769000895119729307495913024360169904315078028798025169985966732789207320203861858234048872508633514498384390497048416012928086480326832803, 45471765180330439060504647480621449634904192839383897212809808339619841633826534856109999027962620381874878086991125854247108359699799913776917227058286090426484548349388138935504299609200377899052716663351188664096302672712078508601311725863678223874157861163196340391008634419348573975841578359355931590555, 17364140182001694956465593533200623738590196990236340894554145562517924989208719245429557645254953527658049246737589538280332010533027062477684237933221198639948938784244510469138826808187365678322547992099715229218615475923754896960363138890331502811292427146595752813297603265829581292183917027983351121325, 14388109104985808487337749876058284426747816961971581447380608277949200244660381570568531129775053684256071819837294436069133592772543582735985855506250660938574234958754211349215293281645205354069970790155237033436065434572020652955666855773232074749487007626050323967496732359278657193580493324467258802863, 4379499308310772821004090447650785095356643590411706358119239166662089428685562719233435615196994728767593223519226235062647670077854687031681041462632566890129595506430188602238753450337691441293042716909901692570971955078924699306873191983953501093343423248482960643055943413031768521782634679536276233318, 85256449776780591202928235662805033201684571648990042997557084658000067050672130152734911919581661523957075992761662315262685030115255938352540032297113615687815976039390537716707854569980516690246592112936796917504034711418465442893323439490171095447109457355598873230115172636184525449905022174536414781771, 50576597458517451578431293746926099486388286246142012476814190030935689430726042810458344828563913001012415702876199708216875020997112089693759638454900092580746638631062117961876611545851157613835724635005253792316142379239047654392970415343694657580353333217547079551304961116837545648785312490665576832987, 96868738830341112368094632337476840272563704408573054404213766500407517251810212494515862176356916912627172280446141202661640191237336568731069327906100896178776245311689857997012187599140875912026589672629935267844696976980890380730867520071059572350667913710344648377601017758188404474812654737363275994871, 4881261656846638800623549662943393234361061827128610120046315649707078244180313661063004390750821317096754282796876479695558644108492317407662131441224257537276274962372021273583478509416358764706098471849536036184924640593888902859441388472856822541452041181244337124767666161645827145408781917658423571721, 18237936726367556664171427575475596460727369368246286138804284742124256700367133250078608537129877968287885457417957868580553371999414227484737603688992620953200143688061024092623556471053006464123205133894607923801371986027458274343737860395496260538663183193877539815179246700525865152165600985105257601565]

def getResidue(a, p):
    temp = (p-1) // 2 
    return pow(a, temp, p)

for i in range( len(ints) ):
    checkIfResidue = getResidue(ints[i], prime)
    if(checkIfResidue == 1):
        quadraticResidue = ints[i]

temp = (prime + 1) // 4
print( pow(quadraticResidue, temp, prime) )

```

And after running the program, I got the flag (the root) :

![CryptoHack Image](/assets/img/exploitImages/cryptoHack/img50.png)

**Flag :** 93291799125366706806545638475797430512104976066103610269938025709952247020061090804870186195285998727680200979853848718589126765742550855954805290253592144209552123062161458584575060939481368210688629862036958857604707468372384278049741369153506182660264876115428251983455344219194133033177700490981696141526

<br/>

# Modular Square Root (Modular Math)

![CryptoHack Image](/assets/img/exploitImages/cryptoHack/img52.png)

As shown in the image above, the output.txt file contains an integer `a` and odd prime `p` and I am supposed to compute the square root (x) in x^2 congruent to a mod (p) using the Tonelli-Shanks algorithm as Fermat's little theorem cannot be used as p is congruent to 1 mod 4. I found the Python implementation of the algorithm from this <a href="https://rosettacode.org/wiki/Tonelli-Shanks_algorithm#Python" target="_blank">link</a> and modified it slightly to get the flag (the smaller root).

The code :

```python

#!/usr/bin/env python3

a = 8479994658316772151941616510097127087554541274812435112009425778595495359700244470400642403747058566807127814165396640215844192327900454116257979487432016769329970767046735091249898678088061634796559556704959846424131820416048436501387617211770124292793308079214153179977624440438616958575058361193975686620046439877308339989295604537867493683872778843921771307305602776398786978353866231661453376056771972069776398999013769588936194859344941268223184197231368887060609212875507518936172060702209557124430477137421847130682601666968691651447236917018634902407704797328509461854842432015009878011354022108661461024768

p = 30531851861994333252675935111487950694414332763909083514133769861350960895076504687261369815735742549428789138300843082086550059082835141454526618160634109969195486322015775943030060449557090064811940139431735209185996454739163555910726493597222646855506445602953689527405362207926990442391705014604777038685880527537489845359101552442292804398472642356609304810680731556542002301547846635101455995732584071355903010856718680732337369128498655255277003643669031694516851390505923416710601212618443109844041514942401969629158975457079026906304328749039997262960301209158175920051890620947063936347307238412281568760161

def legendre(a, p):
    return pow(a, (p - 1) // 2, p)
 
def tonelli(n, p):
    assert legendre(n, p) == 1, "not a square (mod p)"
    q = p - 1
    s = 0
    while q % 2 == 0:
        q //= 2
        s += 1
    if s == 1:
        return pow(n, (p + 1) // 4, p)
    for z in range(2, p):
        if p - 1 == legendre(z, p):
            break
    c = pow(z, q, p)
    r = pow(n, (q + 1) // 2, p)
    t = pow(n, q, p)
    m = s
    t2 = 0
    while (t - 1) % p != 0:
        t2 = (t * t) % p
        for i in range(1, m):
            if (t2 - 1) % p == 0:
                break
            t2 = (t2 * t2) % p
        b = pow(c, 1 << (m - i - 1), p)
        r = (r * b) % p
        c = (b * b) % p
        t = (t * c) % p
        m = i
    return r
 
if __name__ == '__main__':
    #ttest = [(10, 13), (56, 101), (1030, 10009), (44402, 100049), (665820697, 1000000009), (881398088036, 1000000000039),
    #(41660815127637347468140745042827704103445750172002, 10**50 + 577)]
    ttest = [(a, p)]

    for n, p in ttest:
        r = tonelli(n, p)
        assert (r * r - n) % p == 0
        print("n : ", n)
        print("p : ", p)
        print("")
        print("roots : %d %d" % (r, p - r))

```

And after running the code I get two roots so I used the smaller one (since that is the flag) :

![CryptoHack Image](/assets/img/exploitImages/cryptoHack/img53.png)

**Flag :** 2362339307683048638327773298580489298932137505520500388338271052053734747862351779647314176817953359071871560041125289919247146074907151612762640868199621186559522068338032600991311882224016021222672243139362180461232646732465848840425458257930887856583379600967761738596782877851318489355679822813155123045705285112099448146426755110160002515592418850432103641815811071548456284263507805589445073657565381850521367969675699760755310784623577076440037747681760302434924932113640061738777601194622244192758024180853916244427254065441962557282572849162772740798989647948645207349737457445440405057156897508368531939120

<br/>

# Chinese Remainder Theorem (Modular Math)

![CryptoHack Image](/assets/img/exploitImages/cryptoHack/img54.png)

As shown in the image above, I have to find the integer a such that x is congruent to a(mod 935). 17 times 11 times 5 gives 935. This <a href="https://www.youtube.com/watch?v=zIFehsBHB8o" target="_blank">video</a> explained the Chinese Remainder Theorem really well. Based on that I did the following working to get the integer a :

![CryptoHack Image](/assets/img/exploitImages/cryptoHack/img55.png)

**Flag :** 872
