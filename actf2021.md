---
layout: page
title: Angstrom 2021 CTF Writeup
---
<hr/>

Me and my team competed in the Montgomery Blair High School's Angstrom CTF event (Saturday, 3rd April, 0:00 UTC - Wednesday, 7th April, 23:59 UTC). This was my longest CTF yet (5 days, 120 hours). We ranked 278th out of 1502 teams (1245 scoring).

I managed to solve 6 challenges (and fill out one survey :D), most of which involved binary exploitation.

Below are the writeups for the challenges that I managed to solve :

<br/>

# Float On 

![ACTF 2021 Writeup](/assets/img/ctfImages/actf2021/img1.png)

Source code :

``` c

#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include <assert.h>

#define DO_STAGE(num, cond) do {\
    printf("Stage " #num ": ");\
    scanf("%lu", &converter.uint);\
    x = converter.dbl;\
    if(cond) {\
        puts("Stage " #num " passed!");\
    } else {\
        puts("Stage " #num " failed!");\
        return num;\
    }\
} while(0);

void print_flag() {
    FILE* flagfile = fopen("flag.txt", "r");
    if (flagfile == NULL) {
        puts("Couldn't find a flag file.");
        return;
    }
    char flag[128];
    fgets(flag, 128, flagfile);
    flag[strcspn(flag, "\n")] = '\x00';
    puts(flag);
}

union cast {
    uint64_t uint;
    double dbl;
};

int main(void) {
    union cast converter;
    double x;

    DO_STAGE(1, x == -x);
    DO_STAGE(2, x != x);
    DO_STAGE(3, x + 1 == x && x * 2 == x);
    DO_STAGE(4, x + 1 == x && x * 2 != x);
    DO_STAGE(5, (1 + x) - 1 != 1 + (x - 1));

    print_flag();

    return 0;
}

```

The challenge involved passing the 5 stages as shown above, once you did that you get the flag. The vulnerability in the source code lies in the conversion of the input from an unsigned 64 bit integer to a 64 bit double (all doubles are signed). 

Passing the first stage (x == -x) was easy, just input 0. For the second stage, I just inputted really large number (18446744073709551616). I did the same thing for stage 5, I inputted a really large number (7482937498982349829478723478238794879234789234). However stage 3 and 4 proved to be quite challenging. 

After a lot of Googling and trying to understand how doubles worked, I learnt that doubles could hold undefined and unrepresentable numbers (<a href="https://en.wikipedia.org/wiki/NaN" target="_blank">NaN</a> - Not a Number). I found a <a href="https://stackoverflow.com/questions/36151158/how-are-nan-and-infinity-of-a-float-or-double-stored-in-memory" target="_blank">Stack Overflow</a> answer which listed the 64 bit binary representations of different NaNs.

For stage 3, I converted the 64 bit binary (1111111111110000000000000000000000000000000000000000000000000000) for a type of NaN - negative infinity to an integer (18442240474082181120). That worked as an input and stage 3 was passed!

For stage 4, I converted the 64 bit binary (1111111111110000000000000000000000000000000000000000000000000000) for a type of NaN - negative infinity to an integer (18442240474082181120). That worked as an input and stage 3 was passed!
