---
layout: page
title: Angstrom 2021 CTF Writeup
---
<hr/>

Me and my team competed in the Montgomery Blair High School's Angstrom CTF event (Saturday, 3rd April, 0:00 UTC - Wednesday, 7th April, 23:59 UTC). This was my longest CTF yet (5 days, 120 hours). We ranked 278th out of 1502 teams (1245 scoring).

I managed to solve 6 challenges (and fill out one survey :D), most of which involved binary exploitation.

Below are the writeups for the challenges that I managed to solve :

<br/>

# Float On 

![ACTF 2021 Writeup](/assets/img/ctfImages/actf2021/img1.png)

Source code :

``` c

#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include <assert.h>

#define DO_STAGE(num, cond) do {\
    printf("Stage " #num ": ");\
    scanf("%lu", &converter.uint);\
    x = converter.dbl;\
    if(cond) {\
        puts("Stage " #num " passed!");\
    } else {\
        puts("Stage " #num " failed!");\
        return num;\
    }\
} while(0);

void print_flag() {
    FILE* flagfile = fopen("flag.txt", "r");
    if (flagfile == NULL) {
        puts("Couldn't find a flag file.");
        return;
    }
    char flag[128];
    fgets(flag, 128, flagfile);
    flag[strcspn(flag, "\n")] = '\x00';
    puts(flag);
}

union cast {
    uint64_t uint;
    double dbl;
};

int main(void) {
    union cast converter;
    double x;

    DO_STAGE(1, x == -x);
    DO_STAGE(2, x != x);
    DO_STAGE(3, x + 1 == x && x * 2 == x);
    DO_STAGE(4, x + 1 == x && x * 2 != x);
    DO_STAGE(5, (1 + x) - 1 != 1 + (x - 1));

    print_flag();

    return 0;
}

```

The challenge involved passing the 5 stages as shown above, once you did that you get the flag. The vulnerability in the source code lies in the conversion of the input from an unsigned 64 bit integer to a 64 bit double (all doubles are signed)/
