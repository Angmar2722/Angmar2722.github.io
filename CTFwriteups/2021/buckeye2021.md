---
layout: page
title: Buckeye 2021 CTF Writeup
---
<hr/>

![Buckeye 2021 CTF Writeup](/assets/img/ctfImages/2021/buckeye2021/logo.png)

I participated in <a href="https://ctftime.org/event/1434" target="_blank">Ohio State University's Buckeye CTF 2021</a> event, playing as part of Social Engineering Experts over the weekend (Sat, 23 Oct. 2021, 08:00 SGT â€” Mon, 25 Oct. 2021, 08:00 SGT). The CTF went really well for us and this is my best performance in terms of ranking in any CTF that I have gone for yet. In the end we ranked 7<sup>th</sup> out of 505 scoring teams.

![Buckeye 2021 CTF Writeup](/assets/img/ctfImages/2021/buckeye2021/scoreboard.png)

I managed to sweep all the crypto challenges and even got a first blood. I also learnt about how neural networks work at a very high level while solving the 'Neurotic' reverse engineering challenge with Diamondroxxx. Overall it was a pretty fun CTF. Note that the challenges marked as 'easy' started out at 100 points whilst the other challenges started at 500 points. On a side note, the site used the <a href="https://github.com/redpwn/rctf" target="_blank">rctf</a> platform which looks minimalist and gorgeous! 

Below are the writeups :

<br/>

| Challenge | Category | Points | Solves | 
| ------------- |  ------- | --- | ---: |
|[Pseudo](#pseudo) | Crypto | 476 | 15 | 
|[Super VDF](#super-vdf) | Crypto | 476 | 15 | 
|[Elliptigo](#elliptigo) | Crypto | 465 | 21 | 
|[Neurotic](#neurotic) | Rev | 441 | 33 | 
|[Defective RSA](#defective-rsa) | Crypto | 441 | 33 | 
|[Key Exchange 2](#key-exchange-2) | Crypto | 90 | 34 | 
|[Ret4win](#ret4win) | Pwn | 90 | 58 | 
|[Buttons](#buttons) | Rev | 85 | 166 | 
|[Key Exchange](#key-exchange) | Crypto | 40 | 141 | 
|[Survey](#survey) | Crypto | 1 | 52 | 
|[Sanity Check](#sanity-check) | Misc | 1 | 426 | 

<br/>

<br/>

## Pseudo

![Buckeye 2021 CTF Writeup](/assets/img/ctfImages/2021/buckeye2021/img1.png)

The server source Code provided :

```python

#!/usr/bin/env python3
import random
import os

rand = random.SystemRandom()
FLAG = b"buckeye{?????????????????????}"


def is_prime(n, rounds=32):
    return all(pow(rand.randrange(2, n), n - 1, n) == 1 for _ in range(rounds))


class RNG:
    def __init__(self, p: int, a: int):
        self.p = p
        self.a = a

    def next_bit(self) -> int:
        ans = pow(self.a, (self.p - 1) // 2, self.p)
        self.a += 1
        return int(ans == 1)

    def next_byte(self) -> int:
        ans = 0
        for i in range(8):
            ans |= self.next_bit() << i
        return ans

    def next_bytes(self, n: int) -> bytes:
        return bytes(self.next_byte() for _ in range(n))


def main():
    p = int(input("Give me a prime number: "))

    if not (256 <= p.bit_length() <= 512):
        print("Wrong bit length")
        return

    if not is_prime(p):
        print("Fermat tells me your number isn't prime")
        return

    a = rand.randrange(2, p)
    rng = RNG(p, a)

    plaintext = b"Hello " + os.urandom(48).hex().encode()
    print("Have some ciphertexts:")

    for _ in range(32):
        s = rng.next_bytes(len(plaintext))
        c = bytes(a ^ b for a, b in zip(s, plaintext))
        print(c.hex())

    if plaintext == input("Guess the plaintext:\n").encode():
        print(f"Congrats! Here's the flag: {FLAG}")
    else:
        print("That's wrong")


main()

```

In this challenge, we have to provide a number `p` between 256 and 512 bits which passes Fermat's primality test. After that, a random plaintext is generated by creating a 102 byte string `a` which consists of 6 bytes of hello and the hex encoding (96 characters but bytes since encoded) of 48 random bytes which is passed into a `RNG` function.  The RNG function effectively creates random bits by computing the Legendre symbol of `a` with respect to `p` and then incrementing `a` after which the next random bit is created in the same manner. The returned bit string is stored in `s` and XORed with the plaintext (the hello plus 48 random bytes) and this is returned as the ciphertext. Our aim is to guess this plaintext. If we guess it correctly, we get the flag.

By definition, the Legendre symbol tells us whether the integer `a` is a quadratic residue modulo `p`. If it is, 1 is returned and if it isn't, in the `RNG` function, 0 is returned. Now what if we provide a **composite** number which passes the primality test? Then nearly always, the `RNG` function's Legendre symbol calculation returns 0 as `p` isn't prime (one could use Jacobi's symbol for checking if `a` is a quadratic residue modulo a composite `n` but that isn't used here). As a result, if we provide a composite, most of the random bytes generated by `RNG` would be 0 and hence when XORed with the plaintext, the plaintext is returned more or less.

Now in the rare case that the Legendre symbol returns 1 instead of 0, our plaintext would be XORed with non zero bytes which might garble a few bytes of the plaintext. As a result, one could use the set of 32 ciphertexts given and check for each of the returned 102 bytes, which is the most commonly occuring byte (since 0 would be returned in most cases). As a result, we could reconstruct the plaintext and hence pass that to get the flag.

To generate a valid pseudoprime (a composite which passes the primality test), one might think of using Carmichael numbers. By definition, a Carmichael number is a composite number <i>n</i> which satisfies the following congruence :

$$ a^{n-1} \ \equiv \ 1 \ (mod  \ n) \quad (a \in \mathbb{Z}^+, \quad \text{gcd(a, n}) \ = \ 1)$$

Here since the base \\( a \\) is a random number between 2 and \\( n \\), we have no way of veifying whether \\( \text{gcd(a, n)} \ = \ 1 \\). As a result, we need to generate strong pseudoprimes which could be done by using a script which generates Miller-Rabin pseudoprimes which we found online. Using the process outlined above, we managed to get the flag.

Our solve script :

```python

import os
from Crypto.Util.number import *
from pwn import *
from sys import stderr
from random import choice, getrandbits
from random import randrange

#https://gist.github.com/keltecc/b5fbd533d2f203e810b43c26ff9d17cc

def miller_rabin(bases, n):
    if n == 2 or n == 3:
        return True

    if n % 2 == 0:
        return False

    r, s = 0, n - 1
    while s % 2 == 0:
        r += 1
        s //= 2
    
    ZmodN = Zmod(n)

    for b in map(ZmodN, bases):
        x = b ^ s
        if x == 1 or x == -1:
            continue
        for _ in range(r - 1):
            x = x ^ 2
            if x == -1:
                break
        else:
            return False
    
    return True


def search_pseudoprime(bases, coeffs, rlen, iters, verbose=False):
    modules = [4 * b for b in bases]

    residues = dict()

    for b, m in zip(bases, modules):
        residues[b] = set()
        for p in primes(3, 1024 * max(bases)):
            if kronecker(b, p) == -1:
                residues[b].add(p % m)

    sets = dict()

    for b, m in zip(bases, modules):
        s = []
        for c in coeffs:
            s.append({(inverse_mod(c, m) * (r + c - 1)) % m for r in residues[b]})
        sets[b] = list(set.intersection(*s))

    # only support this
    assert len(coeffs) == 3

    coeffs_inv = [
        1, 
        coeffs[1] - inverse_mod(coeffs[2], coeffs[1]), 
        coeffs[2] - inverse_mod(coeffs[1], coeffs[2])
    ]

    mod = lcm(modules + coeffs)

    while True:
        choices = [choice(sets[b]) for b in bases]

        rem = crt(
            choices + coeffs_inv,
            bases + coeffs
        )

        if verbose:
            print(f'[*] Searching pseudoprime...', file=stderr)

        for i in range(iters):
            if verbose and i % 10000 == 0:
                print(f'{i}...')

            p1 = getrandbits(rlen) * mod + rem
            p2 = (p1 - 1) * coeffs[1] + 1
            p3 = (p1 - 1) * coeffs[2] + 1

            pprime = p1 * p2 * p3
            
            if miller_rabin(bases, pprime):
                break
        else:
            if verbose:
                print(f'[-] Failed to find pseudoprime, trying with another choices...', file=stderr)
            
            continue

        if verbose:
            print(f'[+] Found pseudoprime!', file=stderr)
            print(f'[+] P = {pprime}', file=stderr)

        return pprime, [p1, p2, p3]

def getMillerRabinPseudoprime():
    rlen = 64
    iters = 30000
    verbose = True

    bases = list(primes(50))
    coeffs = [1, 313, 353]

    pprime, divisors = search_pseudoprime(bases, coeffs, rlen, iters, verbose)

    assert not is_prime(pprime) and \
            miller_rabin(bases, pprime)

    print(f"Successfully generated pseudoprime : {pprime}")
    print(f"Its divisors are {divisors}")
    print(f"Its bit length is {pprime.nbits()}")

    return pprime, divisors

mrPPrime, mrPPrimeDivisors = getMillerRabinPseudoprime()
assert(256 <= mrPPrime.nbits() <= 512)

def is_prime(n, rounds=32):
    return all(pow(randrange(2, n), n - 1, n) == 1 for _ in range(rounds))

for i in range(50): assert is_prime(mrPPrime)


debug = False
local = False

if local:
    r = process(["python3", "chall.py"], level='debug' if debug else None)
else:
    r = remote("crypto.chall.pwnoh.io", 13375, level = 'debug' if debug else None)

r.sendlineafter('Give me a prime number: ', str(mrPPrime))

r.recvuntil('Have some ciphertexts:\n')
ctList = list(str(r.recvline(keepends=False).decode()) for i in range(32))
assert len(ctList) == 32

ctBinList = list(bin(bytes_to_long(bytes.fromhex(ct)))[2:] for ct in ctList)

bitFreqList = []
for i in range(102*8):
    temp = []
    for ct in ctBinList:
        if (len(ct) != 102*8):
            ct = "0" * (102*8 - len(ct)) + ct
        assert len(ct) == 102*8
        temp.append(ct[i])
    bitFreqList.append(temp)

toSend = ""

def most_frequent(List):
    return max(set(List), key = List.count)

toSend = long_to_bytes(int(''.join(list(most_frequent(bit) for bit in bitFreqList)), 2))
print(f"Found secret strin, it is {toSend}")

r.sendline(toSend)
print(r.recvall())

#b"Guess the plaintext:\nCongrats! Here's the flag: b'buckeye{f3rm4t_l13d_t0_m3_0mg}'\n"

```

<p> <b>Flag :</b> buckeye{f3rm4t_l13d_t0_m3_0mg} </p>

<br/>

## Super VDF

![Buckeye 2021 CTF Writeup](/assets/img/ctfImages/2021/buckeye2021/img2.png)

The source code provided :

```python

from gmpy2 import is_prime, mpz
from random import SystemRandom

rand = SystemRandom()
PRIMES = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53]


def get_prime(bit_length):
    while True:
        x = mpz(1)
        while x.bit_length() < bit_length:
            x *= rand.choice(PRIMES)
        if is_prime(x + 1):
            return x + 1


def get_correct_answer():
    # Implementation redacted
    return -1


p = get_prime(1024)
q = get_prime(1024)
n = p * q

print(f"n = {n}")
print("Please calculate (59 ** 59 ** 59 ** 59 ** 1333337) % n")
ans = int(input(">>> "))

if ans == get_correct_answer():
    print("WTF do you own a supercomputer? Here's your flag:")
    print("buckeye{????????????????????????????????????}")
else:
    print("WRONG")

```

The objective of this challenge is to calculate `(59 ** 59 ** 59 ** 59 ** 1333337) % n` where `n` is a semiprime as it is a product of two 1024 bit primes `p` and `q`. Due to how the primes are generated where `p - 1` is a product of some of the primes in the list of `PRIMES` shown in the code above, it means that at most, `p` would be 53-smooth hence Pollard's p-1 factorisation algorithm could be used to factor `n` instantly. As a result, we could obtain `p` and `q` and hence calculate the totient \\( \phi(n) \\).

After that, a clever use of Euler's theorem could be used to compute the desired result. The theorem states that :

$$ a^{\phi(n)} \ \equiv \ 1 \ (mod  \ n) \quad (a \in \mathbb{Z}^+, \quad \text{gcd(a, n}) \ = \ 1)$$

As a result, one can state that :

$$ a^{b^c} \ (mod \ n) \equiv \ a^{b^c \ \text{mod} \ \phi(n)} \ mod \ (n) \quad (a, b, c \in \mathbb{Z}^+, \quad \text{gcd(a and b and c, n}) \ = \ 1)$$

Since we have even more exponents in our case, we would be forming a chain of totitents in a similar manner to the expression shown above where in the case for the next exponent, the totient of the totient would be used. We used this logic to make our solve script :

```python

from pwn import *
from Crypto.Util.number import *

debug = False
r = remote("crypto.chall.pwnoh.io", 13376, level = 'debug' if debug else None)

payload = 1

r.recvuntil('n = ')
n = int(r.recvline().decode())

#Pollard's p-1 factorisation algorithm
def factor(n):
    a = 2
    b = 2
    while True:
        if b % 10000 == 0:
            pass
            
        a = pow(a, b, n)
            
        p = GCD(a - 1, n)
        if 1 < p < n:
            print("FOUND prime factor")
            return p
            
        b += 1

p = factor(n)
q = n // p
assert n == p * q

#Please calculate (59 ** 59 ** 59 ** 59 ** 1333337) % n)

#https://math.stackexchange.com/questions/3558102/how-to-compute-333-phantom-bmod-46-for-pow/3559055
from sympy.ntheory import totient

assert GCD(59, n) == 1

phi = (p - 1) * (q - 1)
secondPhi = totient(phi)
thirdPhi = totient(secondPhi)
fourthPhi = totient(thirdPhi)

answer = pow(59, (pow(59, (pow(59, (pow(59, 1333337 % fourthPhi, thirdPhi)), secondPhi)), phi)), n)
r.sendlineafter('>>> ', str(answer))

print(r.recvall())
#b"WTF do you own a supercomputer? Here's your flag:\nbuckeye{phee_phi_pho_phum_v3ry_stup1d_puzzle}\n"

```

<p> <b>Flag :</b> buckeye{phee_phi_pho_phum_v3ry_stup1d_puzzle} </p>

<br/>

## Elliptigo

![Buckeye 2021 CTF Writeup](/assets/img/ctfImages/2021/buckeye2021/img3.png)

The source code provided :

```python

from Crypto.Cipher import AES
from Crypto.Util.Padding import pad
from Crypto.Util.number import size, long_to_bytes
import os
import hashlib
from collections import namedtuple

FLAG = b"buckeye{???????????????????}"

Point = namedtuple("Point", ("x", "z"))
Curve = namedtuple("Curve", ("a", "b"))

p = 2 ** 255 - 19
C = Curve(486662, 1)

"""
Implements the Montgomery Ladder from https://eprint.iacr.org/2017/212.pdf
"""


def point_add(P: Point, Q: Point, D: Point) -> Point:
    """
    Algorithm 1 (xADD)
    """
    V0 = (P.x + P.z) % p
    V1 = (Q.x - Q.z) % p
    V1 = (V1 * V0) % p
    V0 = (P.x - P.z) % p
    V2 = (Q.x + Q.z) % p
    V2 = (V2 * V0) % p
    V3 = (V1 + V2) % p
    V3 = (V3 * V3) % p
    V4 = (V1 - V2) % p
    V4 = (V4 * V4) % p
    x = (D.z * V3) % p
    z = (D.x * V4) % p
    return Point(x, z)


def point_double(P: Point) -> Point:
    """
    Algorithm 2 (xDBL)
    """
    V1 = (P.x + P.z) % p
    V1 = (V1 * V1) % p
    V2 = (P.x - P.z) % p
    V2 = (V2 * V2) % p
    x = (V1 * V2) % p
    V1 = (V1 - V2) % p
    V3 = (((C.a + 2) // 4) * V1) % p
    V3 = (V3 + V2) % p
    z = (V1 * V3) % p
    return Point(x, z)


def scalar_multiplication(P: Point, k: int) -> Point:
    """
    Algorithm 4 (LADDER)
    """

    if k == 0:
        return Point(0, 0)

    R0, R1 = P, point_double(P)
    for i in range(size(k) - 2, -1, -1):
        if k & (1 << i) == 0:
            R0, R1 = point_double(R0), point_add(R0, R1, P)
        else:
            R0, R1 = point_add(R0, R1, P), point_double(R1)
    return R0


def normalize(P: Point) -> Point:
    if P.z == 0:
        return Point(0, 0)

    return Point((P.x * pow(P.z, -1, p)) % p, 1)


def legendre_symbol(x: int, p: int) -> int:
    return pow(x, (p - 1) // 2, p)


def is_on_curve(x: int) -> bool:
    y2 = x ** 3 + C.a * x ** 2 + C.b * x
    return legendre_symbol(y2, p) != (-1 % p)


def main():
    print("Pick a base point")
    x = int(input("x: "))

    if size(x) < 245:
        print("Too small!")
        return

    if x >= p:
        print("Too big!")
        return

    if not is_on_curve(x):
        print("That x coordinate is not on the curve!")
        return

    P = Point(x, 1)

    a = int.from_bytes(os.urandom(32), "big")
    A = scalar_multiplication(P, a)
    A = normalize(A)

    key = hashlib.sha1(long_to_bytes(A.x)).digest()[:16]

    cipher = AES.new(key, AES.MODE_ECB)
    ciphertext = cipher.encrypt(pad(FLAG, 16))
    print(ciphertext.hex())


if __name__ == "__main__":
    main()

```

We have to provide a point which lies on this Elliptic curve after which a secret scalar multiple is calculated and multiplied with that point. The result is then hashed and used as a key to encrypt the flag using AES. We found <a href="https://crypto.stackexchange.com/questions/82078/curve25519-montgomery-curves-points-with-order-8" target="_blank">this thread</a> which explains how to compute points of low order for a given Elliptic curve and coincidentally, the example used was for a point which has an order of 8 and can hence generate only a really finite set of possible values when any integer is multiplied with that point. 

Using the given values in that thread directly using (the same curve25519 was used) as well as the curve in our challenge, we found that only 2 values were nearly always occuring after multiplying the point with some random integer `a` hence we have two possible keys which can be used to decrypt the flag.

The solve script :

```python

from pwn import *
from Crypto.Util.number import *
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad
from Crypto.Util.number import size, long_to_bytes
import hashlib

#https://crypto.stackexchange.com/questions/82078/curve25519-montgomery-curves-points-with-order-8

debug = True
r = remote("crypto.chall.pwnoh.io", 13373, level = 'debug' if debug else None)

x = 57896044618658097711785492504343953926634992332820282019728792003956564819948

r.sendlineafter('x: ', str(x))

ct = bytes.fromhex(r.recvline(keepends=False).decode())

a1 = 57896044618658097711785492504343953926634992332820282019728792003956564819948
a2 = 0

k1 = hashlib.sha1(long_to_bytes(a1)).digest()[:16]
k2 = hashlib.sha1(long_to_bytes(a2)).digest()[:16]
cipher1 = AES.new(k1, AES.MODE_ECB)
cipher2 = AES.new(k2, AES.MODE_ECB)
pt1 = cipher1.decrypt(pad(ct, 16))
pt2 = cipher2.decrypt(pad(ct, 16))
print(pt1)
print(pt2)

#b'buckeye{p01nt5_0f_l0w_0rd3r}\x04\x04\x04\x04\xb9+\xc6I\xfd\x89\x7f\xcb\x92\xaeQC\x9fw,\x1f'
#b'\xd3&R\xddu~\xa1IL\xee \xf4\x9fE>A&I\xb5\x88P<LW\xcc\xee\x8d\xed\x9e\n\xaf!n\x9d\x9d\xbe\xdd\xe2\xd5\xb6TU\x85\xd0\x9er%\xc9'

```

I managed to solve this challenge really fast and hence got first blood!

![Buckeye 2021 CTF Writeup](/assets/img/ctfImages/2021/buckeye2021/img4.png)

<p> <b>Flag :</b> buckeye{p01nt5_0f_l0w_0rd3r} </p>

<br/>

## Neurotic

![Buckeye 2021 CTF Writeup](/assets/img/ctfImages/2021/buckeye2021/img5.png)

The source code provided :

```python

import torch
from torch import nn
import numpy as np
from functools import reduce
import base64


class NeuralNetwork(nn.Module):
    def __init__(self):
        super(NeuralNetwork, self).__init__()
        self.stack = nn.Sequential(*([nn.Linear(8, 8, bias=False)] * 7))

    def forward(self, x):
        x = self.stack(x)
        return x


device = "cuda" if torch.cuda.is_available() else "cpu"

model = NeuralNetwork().to(device)
torch.save(model.state_dict(), "model.pth")

flag = b"buckeye{???????????????????????????????????????????????????????}"
assert len(flag) == 64
X = np.reshape(list(flag), (8, 8)).astype(np.float32)

Xt = torch.from_numpy(X).to(device)
Y = model(Xt).detach().numpy()

print(base64.b64encode(Y).decode())
# Output: 1VfgPsBNALxwfdW9yUmwPpnI075HhKg9bD5gPDLvjL026ho/xEpQvU5D4L3mOso+KGS7vvpT5T0FeN284inWPXyjaj7oZgI8I7q5vTWhOj7yFEq+TtmsPaYN7jxytdC9cIGwPti6ALw28Pm9eFZ/PkVBV75iV/U9NoP4PDoFn72+rI8+HHZivMwJvr2s5IQ+nASFvhoW2j1+uHE98MbuvdSNsT4kzrK82BGLvRrikz6oU66+oCGCPajDmzyg7Q69OjiDPvQtnjxwWw2+IB9ZPmaCLb4Mwhc+LimEPXXBQL75OQ8/ulQUvZZMsr3iO88+ZHz3viUgLT2U/d68C2xYPQ==

```
