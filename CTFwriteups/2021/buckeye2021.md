---
layout: page
title: Buckeye 2021 CTF Writeup
---
<hr/>

![Buckeye 2021 CTF Writeup](/assets/img/ctfImages/2021/buckeye2021/logo.png)

I participated in <a href="https://ctftime.org/event/1434" target="_blank">Ohio State University's Buckeye CTF 2021</a> event, playing as part of Social Engineering Experts over the weekend (Sat, 23 Oct. 2021, 08:00 SGT â€” Mon, 25 Oct. 2021, 08:00 SGT). The CTF went really well for us and this is my best performance in terms of ranking in any CTF that I have gone for yet. In the end we ranked 7<sup>th</sup> out of 505 scoring teams.

![Buckeye 2021 CTF Writeup](/assets/img/ctfImages/2021/buckeye2021/scoreboard.png)

I managed to sweep all the crypto challenges and even got a first blood. I also learnt about how neural networks work at a very high level while solving the 'Neurotic' reverse engineering challenge with Diamondroxxx. Overall it was a pretty fun CTF. Note that the challenges marked as 'easy' started out at 100 points whilst the other challenges started at 500 points. On a side note, the site used the <a href="https://github.com/redpwn/rctf" target="_blank">rctf</a> platform which looks minimalist and gorgeous! 

Below are the writeups :

<br/>

| Challenge | Category | Points | Solves | 
| ------------- |  ------- | --- | ---: |
|[Pseudo](#pseudo) | Crypto | 476 | 15 | 
|[Super VDF](#super-vdf) | Crypto | 476 | 15 | 
|[Elliptigo](#elliptigo) | Crypto | 465 | 21 | 
|[Neurotic](#neurotic) | Rev | 441 | 33 | 
|[Defective RSA](#defective-rsa) | Crypto | 441 | 33 | 
|[Key Exchange 2](#key-exchange-2) | Crypto | 90 | 34 | 
|[Ret4win](#ret4win) | Pwn | 90 | 58 | 
|[Buttons](#buttons) | Rev | 85 | 166 | 
|[Key Exchange](#key-exchange) | Crypto | 40 | 141 | 
|[Survey](#survey) | Crypto | 1 | 52 | 
|[Sanity Check](#sanity-check) | Misc | 1 | 426 | 

<br/>

<br/>

## Pseudo

![Buckeye 2021 CTF Writeup](/assets/img/ctfImages/2021/buckeye2021/img1.png)

The server source Code provided :

```python

#!/usr/bin/env python3
import random
import os

rand = random.SystemRandom()
FLAG = b"buckeye{?????????????????????}"


def is_prime(n, rounds=32):
    return all(pow(rand.randrange(2, n), n - 1, n) == 1 for _ in range(rounds))


class RNG:
    def __init__(self, p: int, a: int):
        self.p = p
        self.a = a

    def next_bit(self) -> int:
        ans = pow(self.a, (self.p - 1) // 2, self.p)
        self.a += 1
        return int(ans == 1)

    def next_byte(self) -> int:
        ans = 0
        for i in range(8):
            ans |= self.next_bit() << i
        return ans

    def next_bytes(self, n: int) -> bytes:
        return bytes(self.next_byte() for _ in range(n))


def main():
    p = int(input("Give me a prime number: "))

    if not (256 <= p.bit_length() <= 512):
        print("Wrong bit length")
        return

    if not is_prime(p):
        print("Fermat tells me your number isn't prime")
        return

    a = rand.randrange(2, p)
    rng = RNG(p, a)

    plaintext = b"Hello " + os.urandom(48).hex().encode()
    print("Have some ciphertexts:")

    for _ in range(32):
        s = rng.next_bytes(len(plaintext))
        c = bytes(a ^ b for a, b in zip(s, plaintext))
        print(c.hex())

    if plaintext == input("Guess the plaintext:\n").encode():
        print(f"Congrats! Here's the flag: {FLAG}")
    else:
        print("That's wrong")


main()

```

In this challenge, we have to provide a number `p` between 256 and 512 bits which passes Fermat's primality test. After that, a random plaintext is generated by creating a 102 byte string `a` which consists of 6 bytes of hello and the hex encoding (96 characters but bytes since encoded) of 48 random bytes which is passed into a `RNG` function.  The RNG function effectively creates random bits by computing the Legendre symbol of `a` with respect to `p` and then incrementing `a` after which the next random bit is created in the same manner. The returned bit string is stored in `s` and XORed with the plaintext (the hello plus 48 random bytes) and this is returned as the ciphertext. Our aim is to guess this plaintext. If we guess it correctly, we get the flag.

By definition, the Legendre symbol tells us whether the integer `a` is a quadratic residue modulo `p`. If it is, 1 is returned and if it isn't, in the `RNG` function, 0 is returned. Now what if we provide a **composite** number which passes the primality test? Then nearly always, the `RNG` function's Legendre symbol calculation returns 0 as `p` isn't prime (one could use Jacobi's symbol for checking if `a` is a quadratic residue modulo a composite `n` but that isn't used here). As a result, if we provide a composite, most of the random bytes generated by `RNG` would be 0 and hence when XORed with the plaintext, the plaintext is returned more or less.

Now in the rare case that the Legendre symbol returns 1 instead of 0, our plaintext would be XORed with non zero bytes which might garble a few bytes of the plaintext. As a result, one could use the set of 32 ciphertexts given and check for each of the returned 102 bytes, which is the most commonly occuring byte (since 0 would be returned in most cases). As a result, we could reconstruct the plaintext and hence pass that to get the flag.

To generate a valid pseudoprime (a composite which passes the primality test), one might think of using Carmichael numbers. By definition, a Carmichael number is a composite number <i>n</i> which satisfies the following congruence :

$$ a^{n-1} \ \equiv \ 1 \ (mod  \ n) \quad (a \in \mathbb{Z}^+, \quad \text{gcd(a, n}) \ = \ 1)$$

Here since the base \\( a \\) is a random number between 2 and \\( n \\), we have no way of veifying whether \\( \text{gcd(a, n) \ = \ 1 \\). As a result, we need to generate strong pseudoprimes which could be done by using a script which generates Miller-Rabin pseudoprimes which we found online. Using the process outlined above, we managed to get the flag.

Our solve script :

```python

import os
from Crypto.Util.number import *
from pwn import *
from sys import stderr
from random import choice, getrandbits
from random import randrange

#https://gist.github.com/keltecc/b5fbd533d2f203e810b43c26ff9d17cc

def miller_rabin(bases, n):
    if n == 2 or n == 3:
        return True

    if n % 2 == 0:
        return False

    r, s = 0, n - 1
    while s % 2 == 0:
        r += 1
        s //= 2
    
    ZmodN = Zmod(n)

    for b in map(ZmodN, bases):
        x = b ^ s
        if x == 1 or x == -1:
            continue
        for _ in range(r - 1):
            x = x ^ 2
            if x == -1:
                break
        else:
            return False
    
    return True


def search_pseudoprime(bases, coeffs, rlen, iters, verbose=False):
    modules = [4 * b for b in bases]

    residues = dict()

    for b, m in zip(bases, modules):
        residues[b] = set()
        for p in primes(3, 1024 * max(bases)):
            if kronecker(b, p) == -1:
                residues[b].add(p % m)

    sets = dict()

    for b, m in zip(bases, modules):
        s = []
        for c in coeffs:
            s.append({(inverse_mod(c, m) * (r + c - 1)) % m for r in residues[b]})
        sets[b] = list(set.intersection(*s))

    # only support this
    assert len(coeffs) == 3

    coeffs_inv = [
        1, 
        coeffs[1] - inverse_mod(coeffs[2], coeffs[1]), 
        coeffs[2] - inverse_mod(coeffs[1], coeffs[2])
    ]

    mod = lcm(modules + coeffs)

    while True:
        choices = [choice(sets[b]) for b in bases]

        rem = crt(
            choices + coeffs_inv,
            bases + coeffs
        )

        if verbose:
            print(f'[*] Searching pseudoprime...', file=stderr)

        for i in range(iters):
            if verbose and i % 10000 == 0:
                print(f'{i}...')

            p1 = getrandbits(rlen) * mod + rem
            p2 = (p1 - 1) * coeffs[1] + 1
            p3 = (p1 - 1) * coeffs[2] + 1

            pprime = p1 * p2 * p3
            
            if miller_rabin(bases, pprime):
                break
        else:
            if verbose:
                print(f'[-] Failed to find pseudoprime, trying with another choices...', file=stderr)
            
            continue

        if verbose:
            print(f'[+] Found pseudoprime!', file=stderr)
            print(f'[+] P = {pprime}', file=stderr)

        return pprime, [p1, p2, p3]

def getMillerRabinPseudoprime():
    rlen = 64
    iters = 30000
    verbose = True

    bases = list(primes(50))
    coeffs = [1, 313, 353]

    pprime, divisors = search_pseudoprime(bases, coeffs, rlen, iters, verbose)

    assert not is_prime(pprime) and \
            miller_rabin(bases, pprime)

    print(f"Successfully generated pseudoprime : {pprime}")
    print(f"Its divisors are {divisors}")
    print(f"Its bit length is {pprime.nbits()}")

    return pprime, divisors

mrPPrime, mrPPrimeDivisors = getMillerRabinPseudoprime()
assert(256 <= mrPPrime.nbits() <= 512)

def is_prime(n, rounds=32):
    return all(pow(randrange(2, n), n - 1, n) == 1 for _ in range(rounds))

for i in range(50): assert is_prime(mrPPrime)


debug = False
local = False

if local:
    r = process(["python3", "chall.py"], level='debug' if debug else None)
else:
    r = remote("crypto.chall.pwnoh.io", 13375, level = 'debug' if debug else None)

r.sendlineafter('Give me a prime number: ', str(mrPPrime))

r.recvuntil('Have some ciphertexts:\n')
ctList = list(str(r.recvline(keepends=False).decode()) for i in range(32))
assert len(ctList) == 32

ctBinList = list(bin(bytes_to_long(bytes.fromhex(ct)))[2:] for ct in ctList)

bitFreqList = []
for i in range(102*8):
    temp = []
    for ct in ctBinList:
        if (len(ct) != 102*8):
            ct = "0" * (102*8 - len(ct)) + ct
        assert len(ct) == 102*8
        temp.append(ct[i])
    bitFreqList.append(temp)

toSend = ""

def most_frequent(List):
    return max(set(List), key = List.count)

toSend = long_to_bytes(int(''.join(list(most_frequent(bit) for bit in bitFreqList)), 2))
print(f"Found secret strin, it is {toSend}")

r.sendline(toSend)
print(r.recvall())

#b"Guess the plaintext:\nCongrats! Here's the flag: b'buckeye{f3rm4t_l13d_t0_m3_0mg}'\n"

```

<p> <b>Flag :</b> buckeye{f3rm4t_l13d_t0_m3_0mg} </p>


