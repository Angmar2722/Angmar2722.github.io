---
layout: page
title: CSAW Quals 2021 CTF Writeup
---
<hr/>

![CSAW Quals 2021 Writeup](/assets/img/ctfImages/2021/csaw2021/logo.png)

During the weekend, I participated in the <a href="https://ctftime.org/event/1315" target="_blank">New York University Tandon School of Engineering's CSAW Quals 2021 CTF</a> event (Sat, 11 Sept. 2021, 04:00 SGT — Mon, 13 Sept. 2021, 04:00 SGT), playing as part of Social Engineering Experts. I was really, really, really looking forward to this CTF as it is a pretty famous one and has a rich history behind it. The CTF started at 4 am on Saturday and after nearly 2 days of grinding, we managed to rank 23<sup>rd</sup> out of 1216 scoring teams :

![CSAW Quals 2021 Writeup](/assets/img/ctfImages/2021/csaw2021/img1.png)

Me and Diamondroxxx once again worked together on some of the challenges and in the end, we managed to sweep the crypto challenges :

![CSAW Quals 2021 Writeup](/assets/img/ctfImages/2021/csaw2021/img5.png)

At one point in the CTF (nearly a day in), we even managed to <a href="https://github.com/Angmar2722/Angmar2722.github.io/blob/master/assets/img/ctfImages/2021/csaw2021/img4.png" target="_blank">breach the top 10</a> but although it didn't last long, this was easily my most successful CTF yet. I really enjoyed the cryptography challenges and learnt quite a lot including some aspects of the <a href="https://www.rust-lang.org/" target="_blank">Rust programming language</a>. I managed to solve 9 challenges, some of them in close collaboration with Diamondroxxx.

Below are the writeups :

<br/>

| Challenge | Category | Points | Solves | 
| ------------- |  ------- | --- | ---: |
|[Bits](#bits) | Crypto | 497 | 24 | 
|[ECC Pop Quiz](#ecc-pop-quiz) | Crypto | 478 | 63 | 
|[Forgery](#forgery) | Crypto | 405 | 127 | 
|[RSA Pop Quiz](#rsa-pop-quiz) | Crypto | 390 | 137 | 
|[Alien Math](#alien-math) | Pwn | 60 | 272 | 
|[Crack Me](#crack-me) | Warm-up | 25 | 367 | 
|[Password Checker](#password-checker) | Warm-up | 25 | 410 | 
|[Survey Says](#survey-says) | Crypto | 10 | 452 | 
|[Welcome](#welcome) | Crypto | 1 | 760 | 

<br/>

<br/>

## Bits

![CSAW Quals 2021 Writeup](/assets/img/ctfImages/2021/csaw2021/img6.png)

The server source Code provided (written in Rust) :

```rust

use std::io::BufRead;
use getrandom::getrandom;
use rug::{
    rand::{RandGen,RandState},
    Integer
};
use sha2::{Sha256,Digest};
use aes::{Aes256,Aes256Ctr,NewBlockCipher,cipher::{FromBlockCipher,StreamCipher}};
use generic_array::GenericArray;

// Secret sauce
// N = p*q; p ≡ q ≡ 3 (mod 4); p, q prime
use hardcore::{dlog, N, G, ORDER, FLAG};

struct SystemRandom;
impl RandGen for SystemRandom {
    fn gen(&mut self) -> u32 {
        let mut buf: [u8; 4] = [0; 4];
        let _ = getrandom(&mut buf).unwrap();
        ((buf[0] as u32) << 24) | ((buf[1] as u32) << 16) | ((buf[2] as u32) << 8) | (buf[3] as u32)
    }
}

fn encrypt_flag(shared: Integer) {
    let mut hasher = Sha256::new();
    hasher.update(shared.to_string());
    let key = hasher.finalize();
    let mut cipher = Aes256Ctr::from_block_cipher(
        Aes256::new_from_slice(&key.as_slice()).unwrap(),
        &GenericArray::clone_from_slice(&[0; 16])
        );
    let mut flag = FLAG.clone();
    cipher.apply_keystream(&mut flag);
    println!("FLAG = {}", flag.iter().map(|c| format!("{:02x}", c)).collect::<String>());
}

fn main() {
    println!("+++++++++++++++++++++++++++++++++++++++++++++++\n\
              + I hear there's a mythical oracle at Delphi. +\n\
              +++++++++++++++++++++++++++++++++++++++++++++++\n");
    let mut sysrng = SystemRandom;
    let mut rnd = RandState::new_custom(&mut sysrng);
    let d = Integer::from(&*ORDER).random_below(&mut rnd);
    let publ = Integer::from(&*G).pow_mod(&d, &*N).unwrap();
    let nbits = ORDER.significant_bits();
    let alice = Integer::from(&*G).pow_mod(&Integer::from(&*ORDER).random_below(&mut rnd), &*N).unwrap();
    println!("N = {}\nG = {}\npubl = {}\nalice = {}\nnbits = {}",
        *N,
        *G,
        publ,
        alice,
        nbits);
    encrypt_flag(alice.pow_mod(&d, &N).unwrap());
    for line in std::io::stdin().lock().lines() {
        let input = line.unwrap().parse::<Integer>().unwrap();
        match dlog(input.clone()) {
            None => println!("-1"),
            Some(x) => {
                assert!(G.clone().pow_mod(&x, &*N).unwrap() == input % &*N);
                assert!(x < *ORDER);
                assert!(x >= 0);
                println!("{}", x.get_bit(nbits - 123) as i32)
            }
        }
    }
}

```

Let's break down the server code. We have a composite modulus <i>N</i> which is generated using two primes <i>P</i> and <i>Q</i>. It is also mentioned that <i>P ≡ Q ≡ 3 mod 4</i> which means that <i>N</i> is a Blum integer. In mathematics, a natural number <i>n</i> is a Blum integer if <i>n = P×Q</i> is a semiprime for which <i>p</i> and <i>q</i> are distinct prime numbers congruent to 3 mod 4. When we connect to the server, a random secret integer <i>d</i> is generated using `RandGen`. The secret integer <i>d</i> lies between the 0 and the order of <i>N</i>. An order of a cyclic group modulo <i>N</i> is the smallest number <i>k</i> such that <i>G<sup>k</sup> ≡ 1 mod N</i>. In our case the order would be Euler's totient function so <i>=(P- 1)*(Q - 1)</i> hence <i>G<sup>(P-1)*(Q-1)</sup> ≡ 1 mod N</i>. A constant generator <i>G</i> is used whose value is fixed as 2. Note that we will refer to <i>G</i> as a generator despite the fact that no <i>G</i> can generate all the elements in the cyclic group of units (integers whose modular multiplicative inverses exist with respect to <i>N</i>) modulo <i>N</i> where <i>N</i> is the product of two odd primes. . The public key is calculated such that <i>pubKey ≡ G<sup>d</sup> mod N</i>.

After the generation of the public key, Alice's public key is generated using a similar method where a secret integer <i>x</i> is generated such that it lies between 0 and the order of <i>N</i> and her public key is calculated such that <i>Alice pubKey ≡ G<sup>x</sup> mod N</i>. Then 5 public parameters are given to us, the composite <i>N</i>, the generator <i>G</i>, the public key <i>publ</i>, Alice's public key <i>alice</i> and importantly the number of bits of the order as explained earlier. The composite, generator and order bit values are always constant (the order bit length is always 1006 bits) when we connect to the sever, the only random values are the public keys since the integers are randomly generated. After being these parameters, the function `encrypt_flag` is called which takes in <i>alice<sup>d</sup> mod N</i>. After that, this value is converted to a string and then hashed using SHA-256 and used as a key for the encryption of the flag using AES-CTR mode. 
    
Importantly, we have an oracle which responds to a specific type of query. Based on our input number <i>y</i>, the oracle will calculate the corresponding discrete logarithm such that <i>y ≡ G<sup>r</sup> mod N</i>. The number <i>r</i> is called the discrete logarithm of <i>y</i> to the base <i>G</i>. A discrete logarithm is a trapdoor or one-way function because calculating it is easy but reversing it is hard.  If calculating such an integer <i>r</i> for the discrete log based on our input is not possible, the server outputs -1. However, if <i>r</i> does exist, then the 884<sup>th</sup> bit of this <i>r</i> (it is the 884<sup>th</sup> bit because the bit we get is <i>nbits - 123</i> where <i>nbits</i> is always 1006 and the bit extracted starts from 0 to 1005) is outputted to us, so it will either be a 0 or a 1. Thus we have an oracle which calculates a discrete log with respect to <i>G</i> and <i>N</i> based on our input and outputs a specific bit.

Initially, we realized that this challenge had something to do with <a href="https://crypto.stanford.edu/pbc/notes/crypto/hardcore.html" target="_blank">hardcore bits</a> and after some further research, we found a paper titled <a href="https://www.cs.hmc.edu/~rmcknigh/msc/Master%20Thesis%20-%20Richard%20McKnight.pdf" target="_blank">Individual Bit Security of the Discrete Logarithm: Theory and Implementation Using Oracles</a> which outlined an algorithm in Section 6.4.3 where an oracle which reveals the <i>i<sup>th</sup></i> bit can be used to discover all bits below <i>i</i> (so from the <i>i<sup>th</sup></i> bit to the LSB). This algorithm is defined as the 'Right Reduction Technique'.
    
The basic premise of the algorithm is tht we have a 'window' into one cell i.e. the single bit that is leaked. Now although the position of this window cannot be changed, we can slide the bits through this window by passing certain values. In our case, we first create some integer <i>h</i> which is obtained by multiplying itself with <i>G<sup>-2<sup>i</sup></sup></i>. We loop this from <i>nbits</i> to the <i>510<sup>th</sup></i> bit, the reason will be specified later, which has the effect of 'clearing' the first 323 bits from the MSB side as it has the effect of subtracting <i>2<sup>i</sup></i> from <i>a</i>. The reason for this 'clearing' is summarised by the 'bit propagation' in the image below :
    
![CSAW Quals 2021 Writeup](/assets/img/ctfImages/2021/csaw2021/img9.png)
    
For those unfamiliar with how this bit shifting technique works, refer to these more fundamental properties :
    
![CSAW Quals 2021 Writeup](/assets/img/ctfImages/2021/csaw2021/img8.png)

Now the basic premise behind the algorithm is outlined based on the bit propagation techniques outlined earlier as well as the bit outputted by the oracle :
    
![CSAW Quals 2021 Writeup](/assets/img/ctfImages/2021/csaw2021/img10.png)
    
This yields an algorithm for obtaining the 0 to the <i>i<sup>th</sup></i> bit of <i>r</i> from the LSB side :

![CSAW Quals 2021 Writeup](/assets/img/ctfImages/2021/csaw2021/img11.png)
    
When we first created this algorithm, we were unable to obtain the LSB of <i>r</i> so we had two possible values depending on whether the LSB was a 1 or 0. Although we used this algorithm to obtain the first 884 bits of <i>r</i>, we were unable to use the 'Left Reduction Technique' outlined in the paper because it used modular square roots for primes but in our case it is impossible as obtaining a modular square root relates to the integer factorization of <i>N</i> which is impossible! We were stuck for many hours at this point and after a lot of reading, we finally realized how we could use the paper titled <a href="https://core.ac.uk/download/pdf/82468586.pdf" target="_blank">The Discrete Logarithm Modulo a Composite Hides O(n) Bits </a> by Hastad, Schrift and Shamir which outlined a very clever way use the oracle to our advatange in order to obtain the primes <i>P</i> and <i>Q</i>.

In the paper, they have figured out a way to prove there exists an integer <i>S</i> such that <i>G<sup>S</sup> ≡ G<sup>N</sup> mod N</i> where <i>S = P + Q - 1</i> :

![CSAW Quals 2021 Writeup](/assets/img/ctfImages/2021/csaw2021/img12.png)
