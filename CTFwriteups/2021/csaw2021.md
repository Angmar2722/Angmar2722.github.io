---
layout: page
title: CSAW Quals 2021 CTF Writeup
---
<hr/>

![CSAW Quals 2021 Writeup](/assets/img/ctfImages/2021/csaw2021/logo.png)

During the weekend, I participated in the <a href="https://ctftime.org/event/1315" target="_blank">New York University Tandon School of Engineering's CSAW Quals 2021 CTF</a> event (Sat, 11 Sept. 2021, 04:00 SGT — Mon, 13 Sept. 2021, 04:00 SGT), playing as part of Social Engineering Experts. I was really, really, really looking forward to this CTF as it is a pretty famous one and has a rich history behind it. The CTF started at 4 am on Saturday and after nearly 2 days of grinding, we managed to rank 23<sup>rd</sup> out of 1216 scoring teams :

![CSAW Quals 2021 Writeup](/assets/img/ctfImages/2021/csaw2021/img1.png)

Me and Diamondroxxx once again worked together on some of the challenges and in the end, we managed to sweep the crypto challenges :

![CSAW Quals 2021 Writeup](/assets/img/ctfImages/2021/csaw2021/img5.png)

At one point in the CTF (nearly a day in), we even managed to <a href="https://github.com/Angmar2722/Angmar2722.github.io/blob/master/assets/img/ctfImages/2021/csaw2021/img4.png" target="_blank">breach the top 10</a> but although it didn't last long, this was easily my most successful CTF yet. I really enjoyed the cryptography challenges and learnt quite a lot including some aspects of the <a href="https://www.rust-lang.org/" target="_blank">Rust programming language</a>. I managed to solve 9 challenges, some of them in close collaboration with Diamondroxxx.

Below are the writeups :

<br/>

| Challenge | Category | Points | Solves | 
| ------------- |  ------- | --- | ---: |
|[Bits](#bits) | Crypto | 497 | 24 | 
|[ECC Pop Quiz](#ecc-pop-quiz) | Crypto | 478 | 63 | 
|[Forgery](#forgery) | Crypto | 405 | 127 | 
|[RSA Pop Quiz](#rsa-pop-quiz) | Crypto | 390 | 137 | 
|[Alien Math](#alien-math) | Pwn | 60 | 272 | 
|[Crack Me](#crack-me) | Warm-up | 25 | 367 | 
|[Password Checker](#password-checker) | Warm-up | 25 | 410 | 
|[Survey Says](#survey-says) | Crypto | 10 | 452 | 
|[Welcome](#welcome) | Crypto | 1 | 760 | 

<br/>

<br/>

## Bits

![CSAW Quals 2021 Writeup](/assets/img/ctfImages/2021/csaw2021/img6.png)

The server source Code provided (written in Rust) :

```rust

use std::io::BufRead;
use getrandom::getrandom;
use rug::{
    rand::{RandGen,RandState},
    Integer
};
use sha2::{Sha256,Digest};
use aes::{Aes256,Aes256Ctr,NewBlockCipher,cipher::{FromBlockCipher,StreamCipher}};
use generic_array::GenericArray;

// Secret sauce
// N = p*q; p ≡ q ≡ 3 (mod 4); p, q prime
use hardcore::{dlog, N, G, ORDER, FLAG};

struct SystemRandom;
impl RandGen for SystemRandom {
    fn gen(&mut self) -> u32 {
        let mut buf: [u8; 4] = [0; 4];
        let _ = getrandom(&mut buf).unwrap();
        ((buf[0] as u32) << 24) | ((buf[1] as u32) << 16) | ((buf[2] as u32) << 8) | (buf[3] as u32)
    }
}

fn encrypt_flag(shared: Integer) {
    let mut hasher = Sha256::new();
    hasher.update(shared.to_string());
    let key = hasher.finalize();
    let mut cipher = Aes256Ctr::from_block_cipher(
        Aes256::new_from_slice(&key.as_slice()).unwrap(),
        &GenericArray::clone_from_slice(&[0; 16])
        );
    let mut flag = FLAG.clone();
    cipher.apply_keystream(&mut flag);
    println!("FLAG = {}", flag.iter().map(|c| format!("{:02x}", c)).collect::<String>());
}

fn main() {
    println!("+++++++++++++++++++++++++++++++++++++++++++++++\n\
              + I hear there's a mythical oracle at Delphi. +\n\
              +++++++++++++++++++++++++++++++++++++++++++++++\n");
    let mut sysrng = SystemRandom;
    let mut rnd = RandState::new_custom(&mut sysrng);
    let d = Integer::from(&*ORDER).random_below(&mut rnd);
    let publ = Integer::from(&*G).pow_mod(&d, &*N).unwrap();
    let nbits = ORDER.significant_bits();
    let alice = Integer::from(&*G).pow_mod(&Integer::from(&*ORDER).random_below(&mut rnd), &*N).unwrap();
    println!("N = {}\nG = {}\npubl = {}\nalice = {}\nnbits = {}",
        *N,
        *G,
        publ,
        alice,
        nbits);
    encrypt_flag(alice.pow_mod(&d, &N).unwrap());
    for line in std::io::stdin().lock().lines() {
        let input = line.unwrap().parse::<Integer>().unwrap();
        match dlog(input.clone()) {
            None => println!("-1"),
            Some(x) => {
                assert!(G.clone().pow_mod(&x, &*N).unwrap() == input % &*N);
                assert!(x < *ORDER);
                assert!(x >= 0);
                println!("{}", x.get_bit(nbits - 123) as i32)
            }
        }
    }
}

```

Let's break down the server code. We have a composite modulus <i>N</i> which is generated using two primes <i>p</i> and <i>q</i>. It is also mentioned that <i>p ≡ q ≡ 3 mod 4</i> which means that <i>N</i> is a Blum integer. In mathematics, a natural number <i>n</i> is a Blum integer if <i>n = p×q</i> is a semiprime for which <i>p</i> and <i>q</i> are distinct prime numbers congruent to 3 mod 4. When we connect to the server, a random secret integer <i>d</i> is generated using `RandGen`. The secret integer <i>d</i> lies between the 0 and the order of <i>N</i>. An order of a cyclic group modulo <i>N</i> is the smallest number <i>k</i> such that <i>G<sup>k</sup> ≡ 1 mod N</i>. In our case the order would be Euler's totient function so <i>=(p - 1)*(q - 1)</i> hence <i>G<sup>(p-1)*(q-1)</sup> ≡ 1 mod N</i>. A constant generator <i>G</i> is used whose value is fixed as 2. Note that we will refer to <i>G</i> as a generator despite the fact that no <i>G</i> can generate all the elements in the cyclic group of units (integers whose modular multiplicative inverses exist with respect to <i>N</i>) modulo <i>N</i> where <i>N</i> is the product of two odd primes. . The public key is calculated such that <i>pubKey ≡ G<sup>d</sup> mod N</i>.

After the generation of the public key, Alice's public key is generated using a similar method where a secret integer <i>x</i> is generated such that it lies between 0 and the order of <i>N</i> and her public key is calculated such that <i>Alice pubKey ≡ G<sup>x</sup> mod N</i>. Then 5 public parameters are given to us, the composite <i>N</i>, the generator <i>G</i>, the public key <i>publ</i>, Alice's public key <i>alice</i> and importantly the number of bits of the order as explained earlier. The composite, generator and order bit values are always constant (the order bit length is always 1006 bits) when we connect to the sever, the only random values are the public keys since the integers are randomly generated. After being these parameters, the function `encrypt_flag` is called which takes in <i>alice<sup>d</sup> mod N</i>. After that, this value is converted to a string and then hashed using SHA-256 and used as a key for the encryption of the flag using AES-CTR mode. 
    
Importantly, we have an oracle which responds to a specific type of query. Based on our input number <i>y</i>, the oracle will calculate the corresponding discrete logarithm such that <i>y ≡ G<sup>a</sup> mod N</i>. The number <i>a</i> is called the discrete logarithm of <i>y</i> to the base <i>G</i>. A discrete logarithm is a trapdoor or one-way function because calculating it is easy but reversing it is hard.  If calculating such an integer <i>a</i> for the discrete log based on our input is not possible, the server outputs -1. However, if <i>a</i> does exist, then the 883<sup>rd</sup> bit of this <i>a</i> (it is the 883<sup>rd</sup> bit because the bit we get is <i>nbits - 123</i> where <i>nbits</i> is always 1006) is outputted to us, so it will either be a 0 or a 1.

    
    
    
    
