---
layout: page
title: CSAW Quals 2021 CTF Writeup
---
<hr/>

![CSAW Quals 2021 Writeup](/assets/img/ctfImages/2021/csaw2021/logo.png)

During the weekend, I participated in the <a href="https://ctftime.org/event/1315" target="_blank">New York University Tandon School of Engineering's CSAW Quals 2021 CTF</a> event (Sat, 11 Sept. 2021, 04:00 SGT — Mon, 13 Sept. 2021, 04:00 SGT), playing as part of Social Engineering Experts. I was really, really, really looking forward to this CTF as it is a pretty famous one and has a rich history behind it. The CTF started at 4 am on Saturday and after nearly 2 days of grinding, we managed to rank 23<sup>rd</sup> out of 1216 scoring teams :

![CSAW Quals 2021 Writeup](/assets/img/ctfImages/2021/csaw2021/img1.png)

Me and Diamondroxxx once again worked together on some of the challenges and in the end, we managed to sweep the crypto challenges :

![CSAW Quals 2021 Writeup](/assets/img/ctfImages/2021/csaw2021/img5.png)

At one point in the CTF (nearly a day in), we even managed to <a href="https://github.com/Angmar2722/Angmar2722.github.io/blob/master/assets/img/ctfImages/2021/csaw2021/img4.png" target="_blank">breach the top 10</a> but although it didn't last long, this was easily my most successful CTF yet. I really enjoyed the cryptography challenges and learnt quite a lot including some aspects of the <a href="https://www.rust-lang.org/" target="_blank">Rust programming language</a>. I managed to solve 9 challenges, some of them in close collaboration with Diamondroxxx.

Below are the writeups :

<br/>

| Challenge | Category | Points | Solves | 
| ------------- |  ------- | --- | ---: |
|[Bits](#bits) | Crypto | 497 | 24 | 
|[ECC Pop Quiz](#ecc-pop-quiz) | Crypto | 478 | 63 | 
|[Forgery](#forgery) | Crypto | 405 | 127 | 
|[RSA Pop Quiz](#rsa-pop-quiz) | Crypto | 390 | 137 | 
|[Alien Math](#alien-math) | Pwn | 60 | 272 | 
|[Crack Me](#crack-me) | Warm-up | 25 | 367 | 
|[Password Checker](#password-checker) | Warm-up | 25 | 410 | 
|[Survey Says](#survey-says) | Crypto | 10 | 452 | 
|[Welcome](#welcome) | Crypto | 1 | 760 | 

<br/>

<br/>

## Bits

![CSAW Quals 2021 Writeup](/assets/img/ctfImages/2021/csaw2021/img6.png)

The server source Code provided (written in Rust) :

```rust

use std::io::BufRead;
use getrandom::getrandom;
use rug::{
    rand::{RandGen,RandState},
    Integer
};
use sha2::{Sha256,Digest};
use aes::{Aes256,Aes256Ctr,NewBlockCipher,cipher::{FromBlockCipher,StreamCipher}};
use generic_array::GenericArray;

// Secret sauce
// N = p*q; p ≡ q ≡ 3 (mod 4); p, q prime
use hardcore::{dlog, N, G, ORDER, FLAG};

struct SystemRandom;
impl RandGen for SystemRandom {
    fn gen(&mut self) -> u32 {
        let mut buf: [u8; 4] = [0; 4];
        let _ = getrandom(&mut buf).unwrap();
        ((buf[0] as u32) << 24) | ((buf[1] as u32) << 16) | ((buf[2] as u32) << 8) | (buf[3] as u32)
    }
}

fn encrypt_flag(shared: Integer) {
    let mut hasher = Sha256::new();
    hasher.update(shared.to_string());
    let key = hasher.finalize();
    let mut cipher = Aes256Ctr::from_block_cipher(
        Aes256::new_from_slice(&key.as_slice()).unwrap(),
        &GenericArray::clone_from_slice(&[0; 16])
        );
    let mut flag = FLAG.clone();
    cipher.apply_keystream(&mut flag);
    println!("FLAG = {}", flag.iter().map(|c| format!("{:02x}", c)).collect::<String>());
}

fn main() {
    println!("+++++++++++++++++++++++++++++++++++++++++++++++\n\
              + I hear there's a mythical oracle at Delphi. +\n\
              +++++++++++++++++++++++++++++++++++++++++++++++\n");
    let mut sysrng = SystemRandom;
    let mut rnd = RandState::new_custom(&mut sysrng);
    let d = Integer::from(&*ORDER).random_below(&mut rnd);
    let publ = Integer::from(&*G).pow_mod(&d, &*N).unwrap();
    let nbits = ORDER.significant_bits();
    let alice = Integer::from(&*G).pow_mod(&Integer::from(&*ORDER).random_below(&mut rnd), &*N).unwrap();
    println!("N = {}\nG = {}\npubl = {}\nalice = {}\nnbits = {}",
        *N,
        *G,
        publ,
        alice,
        nbits);
    encrypt_flag(alice.pow_mod(&d, &N).unwrap());
    for line in std::io::stdin().lock().lines() {
        let input = line.unwrap().parse::<Integer>().unwrap();
        match dlog(input.clone()) {
            None => println!("-1"),
            Some(x) => {
                assert!(G.clone().pow_mod(&x, &*N).unwrap() == input % &*N);
                assert!(x < *ORDER);
                assert!(x >= 0);
                println!("{}", x.get_bit(nbits - 123) as i32)
            }
        }
    }
}

```

Let's break down the server code. We have a composite modulus <i>N</i> which is generated using two primes <i>P</i> and <i>Q</i>. It is also mentioned that <i>P ≡ Q ≡ 3 mod 4</i> which means that <i>N</i> is a Blum integer. In mathematics, a natural number <i>n</i> is a Blum integer if <i>n = P×Q</i> is a semiprime for which <i>p</i> and <i>q</i> are distinct prime numbers congruent to 3 mod 4. When we connect to the server, a random secret integer <i>d</i> is generated using `RandGen`. The secret integer <i>d</i> lies between the 0 and the order of <i>N</i>. An order of a cyclic group modulo <i>N</i> is the smallest number <i>k</i> such that <i>G<sup>k</sup> ≡ 1 mod N</i>. 

In our case the order would be Euler's totient function so <i>=(P- 1)*(Q - 1)</i> hence <i>G<sup>(P-1)*(Q-1)</sup> ≡ 1 mod N</i>. A constant generator <i>G</i> is used whose value is fixed as 2. Note that we will refer to <i>G</i> as a generator despite the fact that no <i>G</i> can generate all the elements in the cyclic group of units (integers whose modular multiplicative inverses exist with respect to <i>N</i>) modulo <i>N</i> where <i>N</i> is the product of two odd primes. . The public key is calculated such that <i>pubKey ≡ G<sup>d</sup> mod N</i>.

After the generation of the public key, Alice's public key is generated using a similar method where a secret integer <i>x</i> is generated such that it lies between 0 and the order of <i>N</i> and her public key is calculated such that <i>Alice pubKey ≡ G<sup>x</sup> mod N</i>. Then 5 public parameters are given to us, the composite <i>N</i>, the generator <i>G</i>, the public key <i>publ</i>, Alice's public key <i>alice</i> and importantly the number of bits of the order as explained earlier. 

The composite, generator and order bit values are always constant (the order bit length is always 1006 bits) when we connect to the sever, the only random values are the public keys since the integers are randomly generated. After being these parameters, the function `encrypt_flag` is called which takes in <i>alice<sup>d</sup> mod N</i>. After that, this value is converted to a string and then hashed using SHA-256 and used as a key for the encryption of the flag using AES-CTR mode. 
    
Importantly, we have an oracle which responds to a specific type of query. Based on our input number <i>y</i>, the oracle will calculate the corresponding discrete logarithm such that <i>y ≡ G<sup>r</sup> mod N</i>. The number <i>r</i> is called the discrete logarithm of <i>y</i> to the base <i>G</i>. A discrete logarithm is a trapdoor or one-way function because calculating it is easy but reversing it is hard.  If calculating such an integer <i>r</i> for the discrete log based on our input is not possible, the server outputs -1. 

However, if <i>r</i> does exist, then the 884<sup>th</sup> bit of this <i>r</i> (it is the 884<sup>th</sup> bit because the bit we get is <i>nbits - 123</i> where <i>nbits</i> is always 1006 and the bit extracted starts from 0 to 1005) is outputted to us, so it will either be a 0 or a 1. Thus we have an oracle which calculates a discrete log with respect to <i>G</i> and <i>N</i> based on our input and outputs a specific bit.

Initially, we realized that this challenge had something to do with <a href="https://crypto.stanford.edu/pbc/notes/crypto/hardcore.html" target="_blank">hardcore bits</a> and after some further research, we found a paper titled <a href="https://www.cs.hmc.edu/~rmcknigh/msc/Master%20Thesis%20-%20Richard%20McKnight.pdf" target="_blank">Individual Bit Security of the Discrete Logarithm: Theory and Implementation Using Oracles</a> which outlined an algorithm in Section 6.4.3 where an oracle which reveals the <i>i<sup>th</sup></i> bit can be used to discover all bits below <i>i</i> (so from the <i>i<sup>th</sup></i> bit to the LSB). This algorithm is defined as the 'Right Reduction Technique'.
    
The basic premise of the algorithm is tht we have a 'window' into one cell i.e. the single bit that is leaked. Now although the position of this window cannot be changed, we can slide the bits through this window by passing certain values. In our case, we first create some integer <i>h</i> which is obtained by multiplying itself with <i>G<sup>-2<sup>i</sup></sup></i>. We loop this from <i>nbits</i> to the <i>510<sup>th</sup></i> bit, the reason will be specified later, which has the effect of 'clearing' the first 323 bits from the MSB side as it has the effect of subtracting <i>2<sup>i</sup></i> from <i>a</i>. The reason for this 'clearing' is summarised by the 'bit propagation' in the image below :
    
![CSAW Quals 2021 Writeup](/assets/img/ctfImages/2021/csaw2021/img9.png)
    
For those unfamiliar with how this bit shifting technique works, refer to these more fundamental properties :
    
![CSAW Quals 2021 Writeup](/assets/img/ctfImages/2021/csaw2021/img8.png)

Now the basic premise behind the algorithm is outlined based on the bit propagation techniques outlined earlier as well as the bit outputted by the oracle :
    
![CSAW Quals 2021 Writeup](/assets/img/ctfImages/2021/csaw2021/img10.png)
    
This yields an algorithm for obtaining the 0 to the <i>i<sup>th</sup></i> bit of <i>r</i> from the LSB side :

![CSAW Quals 2021 Writeup](/assets/img/ctfImages/2021/csaw2021/img11.png)
    
When we first created this algorithm, we were unable to obtain the LSB of <i>r</i> so we had two possible values depending on whether the LSB was a 1 or 0. Although we used this algorithm to obtain the first 884 bits of <i>r</i>, we were unable to use the 'Left Reduction Technique' outlined in the paper because it used modular square roots for primes but in our case it is impossible as obtaining a modular square root relates to the integer factorization of <i>N</i> which is impossible! We were stuck for many hours at this point and after a lot of reading, we finally realized how we could use the paper titled <a href="https://core.ac.uk/download/pdf/82468586.pdf" target="_blank">The Discrete Logarithm Modulo a Composite Hides O(n) Bits </a> by Hastad, Schrift and Shamir which outlined a very clever way use the oracle to our advatange in order to obtain the primes <i>P</i> and <i>Q</i>.

In the paper, they have figured out a way to prove there exists an integer <i>S</i> such that <i>G<sup>S</sup> ≡ G<sup>N</sup> mod N</i> where <i>S = P + Q - 1</i> :

![CSAW Quals 2021 Writeup](/assets/img/ctfImages/2021/csaw2021/img12.png)

At first we tried to implement the left and right shift reduction techniques outlined in the paper in order to obtain the value of <i>r</i> but we realized that we couldn't do that since the right shift technique involves a specific order in which the generator <i>G</i> was implemented which allowed one to use a related <i>G<sup>1</sup></i> in order to calculate the modular square root with respect to the composite <i>N</i>. However as shown above, we could use the oracle and the right reduction algorithm outlined in the previous paper in order to recover <i>S</i>. Note that the property <i>S = P + Q - 1</i> only holds if and only if the order of <i>G</i> modulo <i>N</i> is greater than equal to <i>P + Q - 1</i> which is the case in our challenge as <i>nbits</i> is 1006 bits while the primes were around 500 bits each. 

Hence, by passing in <i>G<sup>N</sup></i> as our inputs to the oracle, we managed to reconstruct <i>S</i> bit by bit from the MSB side. We knew (and were very happy) that we started obtaining bits of <i>S</i> because we were getting 0 bits from the oracle from the 884<sup>th</sup> to the 504<sup>th</sup> bit and once we reached the 504<sup>th</sup> bit, we started getting bits as 1 as outputted by the oracle. The paper states that the upper bound of <i>S</i> would be <i>n/2 + 1</i> which matched our result as <i>nbits</i> was 1006 bits long hence the bits of <i>S</i> would start appearing at around the 504<sup>th</sup> bit.

Now that we have recovered <i>S</i>, we can solve a pair of linear equations simultaneously as <i>S = P + Q - 1</i> and <i>N = P * Q</i> in order to recover the prime factors <i>P</i> and <i>Q</i>. Using the complete factorization of <i>N</i>, we can <a href="https://crypto.stackexchange.com/questions/21097/discrete-logarithm-modulo-a-smooth-number" target="_blank">easily recover the discrete log</a> using the Chinese Remainder Theorem hence obtaining the secret integer <i>d</i>. From there, we can create the key which is used to encrypt the flag as the flag encryption function takes in <i>alice<sup>d</sup> mod N</i> where we now have all 3 parameters. Note that for computing the discrete log, we used Sage's `.log` function instead of `discrete_log` after reading <a href="https://mystiz.hk/posts/2021-01-03-tetctf-unevaluated/#part-iii-solving-128bit-discrete-logarithm" target="_blank">this writeup</a> and realizing that it is much faster and more powerful. Now that we have the integer used to form the key and encrypt the flag, we know had to decrypt it using the key.

The problem we faced was the Rust implementation of the encrypt flag function. We couldn't simply hash the string of our integer using SHA-256 and use that as the key to decrypt the encrypted flag (ciphertext) provided to use in AES-CTR mode because it seems like that isn't what is happening in the encrypt function in the server code. After many painstaking hours of learning how to use Rust and implement the decryption algorithm ourselves which is nearly identical to the encrypt function due to the nature of how AES-CTR works, we managed to decrypt the flag and get some sort of <a href="https://www.youtube.com/watch?v=uhTCeZasCmc" target="_blank">Youtube video</a>. Even though we had installed the 'aes' dependency, the program couldn't find the module 'Aes256Ctr' even though we had installed the 'aes' dependency. Turns out you had to install the dependency like so `aes = {version = "0.7.5", features = ["ctr"]}`.

Our Sage solve script for obtaining the integer passed in to form the key :

```python

from pwn import *
from Crypto.Util.number import *
from Crypto.Hash import SHA256
from Crypto.Cipher import AES

local = False
debug = False

r = remote("crypto.chal.csaw.io", 5010, level = 'debug') if debug else remote("crypto.chal.csaw.io", 5010)

r.recvuntil(b'N = ')
N = int(r.recvline())
r.recvuntil(b'G = ')
G = mod(int(r.recvline()), N)
r.recvuntil(b'publ = ')
publ = mod(int(r.recvline()), N)
r.recvuntil(b'alice = ')
alice = mod(int(r.recvline()), N)
r.recvuntil(b'nbits = ')
nbits = int(r.recvline())
r.recvuntil(b'FLAG = ')
encryptedFlag = int(r.recvline(), 16)

print(N, G, publ, alice, nbits, encryptedFlag)

#Parameters gotten from the server, note that N and G are always constant :
#N = 1264774171500162520522740123707654912813731191511600716918716574718457223687306654609462735310087859826053230623347849924104479609383350278302774436797213741150063894250655073009487778309401701437562813695437500274843520937515731255706515213415007999907839388181535469916350256765596422669114523648082369
#G = 2
#publ = 424861199968523540408732228099069099948534585512367990869892707674935963900611709427300784616702426814860058729683119622339265528985124052411245179500989114843289071582895607761396828751227690992178572360085027227641972904834296869178989065933598523185690739008294641069176079066328291953808609712486835
#alice = 90569259784101573278544411031411338956193931979912490005184431615233345083120574080916887715932712435195886713763094029537271814590327498828215826994733997547107069622547025263947630030135183039092919240982751438698555258106885502101729360110142535723102744463203618827942784702735872004159590264071557
#encryptedFlag = 6829009975510909842168391069944851160579087967996828690875096804086661197441010759982776605024378472510625940228975023


def oracle(h):
    r.sendline(str(h).encode())
    bit = int(r.recvline(keepends=False).decode())
    return bit

def right_reduction(n, g, h, i):
    R = 0
    for j in range(883, i, -1):
        h *= g^(2^(j-1))
    for j in range(i, 0, -1):
        bit = oracle(h)
        print(f"{j}: {bit}")
        if bit == 1:
            R += 1 << j
            h *= g^-(2^j)
        else:
            pass
        h *= g^(2^(j-1))
    return R


S = right_reduction(N, G, pow(G, N), 510)

if pow(G, S) == pow(G, N):
    print(f"Found {s = }")
elif pow(G, S + 1) == pow(G, N):
    s += 1
    print(f"Found {s = }")


#S = 74059460877869774991785377055039730589891937956359353408293798308304935074434675003466766367942215310608899807698868040431917374002812012518769752694125

var ("P, Q")

eq1 = (S == P + Q - 1) 
eq2 = (N == P * Q)

p = solve([eq1, eq2], [P, Q], solution_dict=True)[0][P]

assert int(N) % int(p) == 0

q = int(N)//int(p)

assert N == p*q


# https://crypto.stackexchange.com/questions/21097/discrete-logarithm-modulo-a-smooth-number

publP = mod(int(publ), p)
publQ = mod(int(publ), q)

y = publP.log(2)
z = publQ.log(2)

d = crt([y, z], [int(p)-1, int(q)-1])

print(f"Found secret integer {d}")
#d = 141969641146171053059785808427582284971104153488378362924480259081962678744549404450587633366558816974500827027761816935772997097895735046172610940767615536538049730214150219410292879721185412328366167886674156648859872376872077587848758737883594528833282986475887300302707668758209237572591894346219310

key = pow(alice, d, N)
print(key)
#key = 594807822095334741057051620171396964019351564890894203928169190126461806308549435025248323868458092982166978694503647098000456023924393502691705391685441611869539041261186566093550374349863029469388639761010988841288179860043880441953525279127769332238007038702727402475636786533812164271387985856187587

```

And after getting that integer, we painstakingly managed to use Rust to decrypt the flag :

```rust

use sha2::{Sha256,Digest};
use aes::{Aes256,Aes256Ctr,NewBlockCipher,cipher::{FromBlockCipher,StreamCipher}};
use generic_array::GenericArray;
use rug::{
    Integer
};
use std::str;

fn encrypt_flag(shared: Integer) {
    let mut hasher = Sha256::new();
    hasher.update(shared.to_string());
    println!("{}", shared.to_string());
    let key = hasher.finalize();
    println!("{:02x}", key);
    let mut cipher = Aes256Ctr::from_block_cipher(
        Aes256::new_from_slice(&key.as_slice()).unwrap(),
        &GenericArray::clone_from_slice(&[0; 16])
        );
    //let mut flag = b"flag{this_is_a_test_flag}".to_vec();
    let mut flag :Vec <u8> = vec![173, 80, 249, 30, 70, 40, 34, 67, 20, 125, 37, 109, 34, 67, 195, 78, 56, 94, 166, 246, 85, 151, 17, 54, 11, 64, 104, 251, 35, 109, 235, 50, 113, 108, 125, 26, 73, 79, 63, 255, 190, 111, 102, 23, 19, 13, 18, 169, 175];
    cipher.apply_keystream(&mut flag);
    println!("{:?}", flag);
    println!("FLAG = {}", flag.iter().map(|c| format!("{:02x}", c)).collect::<String>());
}

fn main() {
    let s1 = "594807822095334741057051620171396964019351564890894203928169190126461806308549435025248323868458092982166978694503647098000456023924393502691705391685441611869539041261186566093550374349863029469388639761010988841288179860043880441953525279127769332238007038702727402475636786533812164271387985856187587";
    let int = s1.parse::<Integer>().unwrap();
    encrypt_flag(int)
    //FLAG = 666c61677b68747470733a2f2f7777772e796f75747562652e636f6d2f77617463683f763d75685443655a6173436d637d
    //b'flag{https://www.youtube.com/watch?v=uhTCeZasCmc}'
}

```

Solving this challenge was particularly special for us. We spent around 15 hours on this challenge and this was probably the first real instance of implementing an algorithm ourselves from a research paper, a useful skill for solving the hardest crypto challenges in CTFs. Also by solving this challenge, we managed to solve all crypto challenges in this CTF which felt awesome!

<p> <b>Flag :</b> flag{https://www.youtube.com/watch?v=uhTCeZasCmc} </p>

<br/>

## ECC Pop Quiz

![CSAW Quals 2021 Writeup](/assets/img/ctfImages/2021/csaw2021/img13.png)
